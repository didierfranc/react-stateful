{"version":3,"file":"react-waterfall.js","sources":["../src/Provider.js","../src/Consumer.js","../src/connect.js","../src/index.js"],"sourcesContent":["// @flow\nimport React from 'react'\n\nexport default class Provider extends React.Component<*> {\n  constructor(props) {\n    super(props)\n    const { store } = props\n    this.state = store.initialState\n    this.value = { actions: store.actions, state: this.state }\n    store.attach(this)\n  }\n\n  render() {\n    const { store } = this.props\n    if (this.state !== this.value.state) {\n      // If state was changed then recreate `this.value` so it will have a different reference\n      // Explained here: https://reactjs.org/docs/context.html#caveats\n      this.value = { actions: store.actions, state: this.state }\n    }\n\n    return (\n      <store.context.Provider value={this.value}>\n        {React.Children.map(this.props.children, child => React.cloneElement(child, { context: store.context }), {})}\n      </store.context.Provider>\n    )\n  }\n}\n","import React from 'react'\n\nclass Prevent extends React.PureComponent<*> {\n  render() {\n    const { _children, ...rest } = this.props\n    return _children()(rest)\n  }\n}\n\nexport default class Consumer extends React.Component<*> {\n  // We do this so the sCU of Prevent will ignore the children prop\n  _children = () => this.props.children\n\n  prevent = ({ state, actions }) => {\n    const { mapStateToProps } = this.props\n    return (\n      <Prevent {...mapStateToProps(state)} actions={actions} _children={this._children} />\n    )\n  }\n\n  render() {\n    const { context } = this.props\n    return (\n      <context.Consumer>\n        {this.prevent}\n      </context.Consumer>\n    )\n  }\n}\n","import React, { forwardRef } from 'react'\nimport Consumer from './Consumer'\n\nconst connect: Function = mapStateToProps => WrappedComponent => {\n  const ConnectComponent = forwardRef((props, ref) =>\n    <Consumer context={props.context} mapStateToProps={mapStateToProps}>\n      {injectedProps => <WrappedComponent {...props} {...injectedProps} ref={ref} />}\n    </Consumer>,\n  )\n\n  ConnectComponent.displayName = `Connect(${WrappedComponent.displayName || WrappedComponent.name || 'Unknown'})`\n  return ConnectComponent\n}\n\nexport default connect\n","// @flow\nimport React from 'react'\n\nexport { default as Provider } from './Provider'\nexport { default as Consumer } from './Consumer'\nexport { default as connect } from './connect'\n\nfunction err() { console.error('Provider is not attached yet') }\n\nfunction setState(action, state, args) {\n  this.subscribers.forEach(fn => fn(action, state, args))\n  this.provider.setState(state, () => this.middlewares.forEach(m => m(action, args)))\n}\n\nclass Store {\n  constructor(config, ...middlewareFactories) {\n    this.config = config\n    this.context = React.createContext()\n    this.initialState = config.initialState\n    this.factories = middlewareFactories\n    this.middlewares = []\n    this.provider = null\n    this.subscribers = []\n    this.actions = Object.keys(config.actions).reduce(\n      (r, v) => ({\n        ...r,\n        [v]: (...args) => {\n          if (this.provider) {\n            let result = config.actions[v](this.provider.state, ...args)\n            result.then\n              ? result.then(result => setState.call(this, v, result, args))\n              : setState.call(this, v, result, args)\n          } else {\n            err()\n          }\n        },\n      }),\n      {},\n    )\n  }\n\n  getState = () => (this.provider ? this.provider.state : err())\n\n  attach = provider => {\n    this.provider = provider\n    this.middlewares = this.factories.map(m => m(this.config, this.provider, this.actions))\n  }\n\n  subscribe = fn => {\n    this.subscribers = [...this.subscribers, fn]\n  }\n}\n\nexport const initStore = (store, ...middlewares) => new Store(store, ...middlewares)\n"],"names":["Provider","props","store","state","initialState","value","actions","_this","attach","React","Component","this","context","Children","map","children","cloneElement","child","Prevent","PureComponent","_children","rest","Consumer","mapStateToProps","prevent","connect","ConnectComponent","forwardRef","ref","WrappedComponent","injectedProps","displayName","name","err","error","setState","action","args","subscribers","forEach","fn","provider","middlewares","m","Store","config","_this2","factories","createContext","middlewareFactories","Object","keys","reduce","r","v","result","then","call","initStore"],"mappings":"ioFAGqBA,gCACPC,qHACJA,QACEC,EAAUD,EAAVC,eACHC,MAAQD,EAAME,eACdC,eAAmBH,EAAMI,cAAgBC,EAAKJ,SAC7CK,uDAN4BC,eAAMC,8DAUhCR,EAAUS,KAAKV,MAAfC,aACJS,KAAKR,QAAUQ,KAAKN,MAAMF,aAGvBE,eAAmBH,EAAMI,cAAgBK,KAAKR,QAInDM,6BAACP,EAAMU,QAAQZ,gBAAgBW,KAAKN,OACjCI,eAAMI,SAASC,IAAIH,KAAKV,MAAMc,SAAU,mBAASN,eAAMO,aAAaC,WAAkBf,EAAMU,yBCpB/FM,kLAAgBT,eAAMU,oEAEOR,KAAKV,MAA5BmB,IAAAA,UAAcC,mDACfD,GAAAA,CAAYC,YAIFC,4YAEP,kBAAMf,EAAKN,MAAMc,uHAEnB,gBAAGZ,IAAAA,MAAOG,IAAAA,QACViB,EAAoBhB,EAAKN,MAAzBsB,uBAENd,6BAACS,oBAAYK,EAAgBpB,YAAiBG,YAAoBC,EAAKa,uCAPvCX,eAAMC,8DAYhCE,EAAYD,KAAKV,MAAjBW,eAENH,6BAACG,EAAQU,cACNX,KAAKa,kBCrBRC,QAAoB,mBAAmB,gBACrCC,EAAmBC,iBAAW,SAAC1B,EAAO2B,UAC1CnB,6BAACa,kBAAkBrB,EAAMW,wBAA0BW,GAChD,mBAAiBd,6BAACoB,cAAqB5B,EAAW6B,OAAoBF,kBAI1DG,8BAAyBF,EAAiBE,aAAeF,EAAiBG,MAAQ,eAC5FN,ICJT,SAASO,cAAgBC,MAAM,gCAE/B,SAASC,SAASC,EAAQjC,EAAOkC,mBAC1BC,YAAYC,QAAQ,mBAAMC,EAAGJ,EAAQjC,EAAOkC,UAC5CI,SAASN,SAAShC,EAAO,kBAAMI,EAAKmC,YAAYH,QAAQ,mBAAKI,EAAEP,EAAQC,WAGxEO,MACJ,WAAYC,6HA0BD,kBAAOC,EAAKL,SAAWK,EAAKL,SAAStC,MAAQ8B,8FAE/C,cACFQ,SAAWA,IACXC,YAAcI,EAAKC,UAAUjC,IAAI,mBAAK6B,EAAEG,EAAKD,OAAQC,EAAKL,SAAUK,EAAKxC,sGAGpE,cACLgC,+BAAkBQ,EAAKR,qBAAaE,YAjCpCK,OAASA,OACTjC,QAAUH,eAAMuC,qBAChB5C,aAAeyC,EAAOzC,wCAHN6C,4DAIhBF,UAAYE,OACZP,oBACAD,SAAW,UACXH,oBACAhC,QAAU4C,OAAOC,KAAKN,EAAOvC,SAAS8C,OACzC,SAACC,EAAGC,2BACCD,qBACFC,EAAI,sCAAIjB,gDACHS,EAAKL,SAAU,OACbc,OAAgBjD,SAAQgD,YAAGR,EAAKL,SAAStC,cAAUkC,MAChDmB,KACHD,EAAOC,KAAK,mBAAUrB,SAASsB,KAAKX,EAAMQ,EAAGC,EAAQlB,KACrDF,SAASsB,KAAKX,EAAMQ,EAAGC,EAAQlB,uBAsBlCqB,UAAY,SAACxD,8BAAUwC,gGAAoBE,qBAAM1C,GAAUwC"}